name: ⏬ Download Memes

on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      disable_cache_check:
        description: 'Disable cache check (true/false)'
        required: false
        default: false
        type: boolean
      show_debug:
        description: 'Enable debug messages (true/false)'
        required: false
        default: false
        type: boolean
      post_limit:
        description: 'Number of posts to fetch from each subreddit'
        required: false
        default: '5'
        type: string

jobs:
  download-memes:
    name: 🌐 Download Memes
    runs-on: ubuntu-latest
    outputs:
      metadata: ${{ steps.collect-metadata.outputs.metadata }}
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 📦 Set Up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: 🧹 Remove Cache
        uses: DareFox/delete-cache-by-key@v1
        with:
          key: meme-ids-cache-
          mode: exact
        continue-on-error: true

      - name: 🚀 Restore Meme IDs Cache
        id: restore-cache
        uses: actions/cache@v4
        with:
          path: cache/meme_ids.json
          key: meme-ids-cache-
          restore-keys: |
            meme-ids-cache-

      - name: 🧰 Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install praw requests yt-dlp

      - name: 🔧 Install Rclone
        run: |
          curl https://rclone.org/install.sh | sudo bash

      - name: 📂 Set Up Rclone Config
        run: |
          mkdir -p ~/.config/rclone
          echo "${{ secrets.PIXELDRAIN_CONF }}" > ~/.config/rclone/rclone.conf

      - name: ⏬ Download Reddit Posts
        id: download-memes
        env:
          CLIENT_ID: ${{ secrets.REDDIT_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.REDDIT_CLIENT_SECRET }}
          USER_AGENT: ${{ secrets.REDDIT_USER_AGENT }}
          DISABLE_CACHE_CHECK: ${{ github.event.inputs.disable_cache_check }}
          SHOW_DEBUG: ${{ github.event.inputs.show_debug || true }}
          POST_LIMIT: ${{ github.event.inputs.post_limit || '5' }}
        run: |
          mkdir -p cache
          python - <<EOF
          import os
          import json
          import requests
          import praw
          import yt_dlp
          import re

          def escape_markdown(text):
              """Escapes Markdown-sensitive characters."""
              escape_chars = r"_*[]()~`>#+-=|{}.!"
              return re.sub(f'([{"".join(re.escape(c) for c in escape_chars)}])', r'\\\1', text)

          client_id = os.getenv("CLIENT_ID")
          client_secret = os.getenv("CLIENT_SECRET")
          user_agent = os.getenv("USER_AGENT")
          disable_cache_check = os.getenv("DISABLE_CACHE_CHECK", "false").lower() == "true"
          show_debug = os.getenv("SHOW_DEBUG", "false").lower() == "true"
          post_limit = int(os.getenv("POST_LIMIT", "5"))
          MEME_LIMIT = 250  # Maximum number of memes to collect

          def debug_log(msg):
              if show_debug:
                  print(f"🛠️ DEBUG: {msg}")

          debug_log("✅ Initializing Reddit client in read-only mode...")
          reddit = praw.Reddit(
              client_id=client_id,
              client_secret=client_secret,
              user_agent=user_agent,
          )

          cache_file = "cache/meme_ids.json"
          try:
              with open(cache_file, "r") as f:
                  cached_ids = set(json.load(f))
              debug_log(f"{len(cached_ids)} cached IDs loaded.")
          except:
              debug_log("⚠️ No valid cache found.")
              cached_ids = set()

          valid_image_exts = ['.png', '.jpg', '.jpeg', '.webp', '.gif']
          subreddits = [
              "memes", "ProgrammerHumor", "dankmemes", "DirtyMemes",
              "rule34", "rareinsults", "futanari", "HardPornGifs",
              "funny", "pics", "science", "todayilearned",
              "porn_gifs", "MemeVideos"
          ]
          total_memes = 0
          new_ids = []
          memes_metadata = []

          for subreddit in subreddits:
              if total_memes >= MEME_LIMIT:
                  break
              debug_log(f"🔄 Fetching latest posts from r/{subreddit}...")
              for post in reddit.subreddit(subreddit).new(limit=post_limit):
                  if not disable_cache_check and post.id in cached_ids:
                      continue
                  try:
                      ext = os.path.splitext(post.url.lower())[1]
                      if ext in valid_image_exts:
                          # Download image
                          r = requests.get(post.url, timeout=10)
                          r.raise_for_status()
                          out_fname = os.path.join("cache", f"{post.id}{ext}")
                          with open(out_fname, "wb") as f_img:
                              f_img.write(r.content)
                          memes_metadata.append({
                              "id": post.id,
                              "title": escape_markdown(post.title),
                              "author": escape_markdown(str(post.author) if post.author else "Unknown"),
                              "subreddit": str(post.subreddit),
                              "upvotes": post.ups,
                              "filename": os.path.basename(out_fname),
                              "type": "image"
                          })
                          new_ids.append(post.id)
                          total_memes += 1
                      else:
                          # Assume video
                          outtmpl = f"cache/{post.id}.%(ext)s"
                          ydl_opts = {
                              'outtmpl': outtmpl,
                              'quiet': not show_debug,
                              'no_warnings': True,
                              'ignoreerrors': True,
                              'format': 'bestvideo+bestaudio/best',
                              'merge_output_format': 'mp4',
                          }
                          with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                              ydl.download([post.url])
                          downloaded_file = None
                          for file in os.listdir("cache"):
                              if file.startswith(post.id):
                                  downloaded_file = os.path.join("cache", file)
                                  break
                          if downloaded_file:
                              # Check file size (Telegram limit: 50MB)
                              file_size = os.path.getsize(downloaded_file)
                              if file_size > 50 * 1024 * 1024:
                                  print(f"⚠️ Video {downloaded_file} exceeds 50MB. Skipping.")
                                  continue
                              memes_metadata.append({
                                  "id": post.id,
                                  "title": escape_markdown(post.title),
                                  "author": escape_markdown(str(post.author) if post.author else "Unknown"),
                                  "subreddit": str(post.subreddit),
                                  "upvotes": post.ups,
                                  "filename": os.path.basename(downloaded_file),
                                  "type": "video"
                              })
                              new_ids.append(post.id)
                              total_memes += 1
                          else:
                              print(f"⚠️ Post {post.id}: Could not save as image or video - skipping.")
                  except Exception as e:
                      print(f"⚠️ Error processing post {post.id}: {e}")

          if new_ids:
              cached_ids.update(new_ids)
              with open(cache_file, "w") as f_cache:
                  json.dump(sorted(cached_ids), f_cache)
              print(f"🎉 Downloaded {len(new_ids)} new items.")
          else:
              print("✨ No New Memes Found!")

          with open("cache/memes_metadata.json", "w") as f_meta:
              json.dump(memes_metadata, f_meta, indent=2)
          EOF

      - name: 🗂️ Collect Metadata
        id: collect-metadata
        run: |
          # Limit to first 250 memes to prevent matrix overflow
          limited_metadata=$(jq '.[:250]' cache/memes_metadata.json)
          metadata=$(echo "$limited_metadata" | jq -c .)
          echo "metadata=$metadata" >> $GITHUB_OUTPUT

      - name: 🌐 Upload Memes with Rclone
        run: |
          rclone copy cache Pixeldrain:"💯 Memes"

      - name: 🔧 Compute Hash of Updated meme_ids.json
        id: compute-hash
        run: |
          if [ -f cache/meme_ids.json ]; then
            FILE_HASH=$(sha256sum cache/meme_ids.json | awk '{print $1}')
          else
            FILE_HASH="empty-cache"
          fi
          echo "hash=$FILE_HASH" >> $GITHUB_ENV

      - name: 💾 Update Meme IDs Cache
        uses: actions/cache@v4
        with:
          path: cache/meme_ids.json
          key: meme-ids-cache-${{ env.hash }}

      - name: 📜 List All Files
        run: |
          tree

      - name: 📤 Upload Cache as Artifact
        uses: actions/upload-artifact@v3
        with:
          name: cache
          path: cache/

  send-to-telegram:
    name: 📤 Send Memes to Telegram
    needs: download-memes
    runs-on: ubuntu-latest
    strategy:
      matrix:
        meme: ${{ fromJson(needs.download-memes.outputs.metadata) }}
    steps:
      - name: 📥 Checkout Code
        uses: actions/checkout@v4

      - name: 📤 Download Cache Artifact
        uses: actions/download-artifact@v3
        with:
          name: cache
          path: cache/

      - name: 📦 Set Up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: 🧰 Install Dependencies for Telegram
        run: |
          pip install requests

      - name: 📤 Send Meme to Telegram
        run: |
          python - <<EOF
          import os
          import requests
          import re
          
          # Configuration from environment variables
          BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
          CHAT_ID = os.getenv('TELEGRAM_CHAT_ID')
          
          MEME_TYPE = os.getenv('MEME_TYPE')
          MEME_TITLE = os.getenv('MEME_TITLE')
          MEME_AUTHOR = os.getenv('MEME_AUTHOR')
          MEME_UPVOTES = os.getenv('MEME_UPVOTES')
          MEME_URL = os.getenv('MEME_URL')
          MEME_FILENAME = os.getenv('MEME_FILENAME')
          
          def escape_markdown(text):
              """Escapes Markdown-sensitive characters."""
              escape_chars = r"_*[]()~`>#+-=|{}.!"
              return re.sub(f'([{"".join(re.escape(c) for c in escape_chars)}])', r'\\\1', text)
          
          def send_photo():
              url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto"
              caption = f"""🎉 **New Meme Alert!**
          📜 *Title:* {escape_markdown(MEME_TITLE)}
          🖋️ *Author:* {escape_markdown(MEME_AUTHOR)}
          👍 *Upvotes:* {MEME_UPVOTES}
          🔗 *URL:* [View Post]({MEME_URL})
          🏷️ *Subreddit:* r/subreddit"""
              with open(MEME_FILENAME, 'rb') as photo:
                  files = {'photo': photo}
                  data = {'chat_id': CHAT_ID, 'caption': caption, 'parse_mode': 'Markdown'}
                  response = requests.post(url, files=files, data=data)
              if not response.ok:
                  print(f"⚠️ Failed to send photo: {response.text}")
          
          def send_video():
              url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendVideo"
              caption = f"""🎉 **New Video Meme Alert!**
          📜 *Title:* {escape_markdown(MEME_TITLE)}
          🖋️ *Author:* {escape_markdown(MEME_AUTHOR)}
          👍 *Upvotes:* {MEME_UPVOTES}
          🔗 *URL:* [View Post]({MEME_URL})
          🏷️ *Subreddit:* r/subreddit"""
              with open(MEME_FILENAME, 'rb') as video:
                  files = {'video': video}
                  data = {'chat_id': CHAT_ID, 'caption': caption, 'parse_mode': 'Markdown'}
                  response = requests.post(url, files=files, data=data)
              if not response.ok:
                  print(f"⚠️ Failed to send video: {response.text}")
          
          def main():
              if MEME_TYPE == 'image':
                  send_photo()
              elif MEME_TYPE == 'video':
                  send_video()
              else:
                  print(f"Unsupported meme type: {MEME_TYPE}")
          
          if __name__ == "__main__":
              main()
          EOF
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_TO }}
          MEME_TYPE: ${{ matrix.meme.type }}
          MEME_TITLE: ${{ matrix.meme.title }}
          MEME_AUTHOR: ${{ matrix.meme.author }}
          MEME_UPVOTES: ${{ matrix.meme.upvotes }}
          MEME_URL: ${{ matrix.meme.url }}
          MEME_FILENAME: cache/${{ matrix.meme.filename }}
        continue-on-error: true
